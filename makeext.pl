#!/usr/bin/perl -w

use strict;
use FileHandle;

my $cmdline = join(' ',$0,@ARGV);
my $out = shift(@ARGV) or die "need output file";
my $in  = shift(@ARGV) or die "need input file";
my $inh = new FileHandle $in, "r" or die "could not open file $in";
open(HEADER,">$out.h");
open(SOURCE,">$out.c");

print SOURCE "/* this file was automatically generated by $cmdline */

#include \"base.h\"
\n";
my @funcnames=();
my @lines=<$inh>;
my $funcre=qr/(\w+\s*\*?)\s+(\w+)\s*\((.*)\)\s*;/;
foreach(@lines) {
	s"#.*"";
	s"//.*"";
	if(m"^\s*$") {next}
	unless(/$funcre/) {next}
	my $rettype=$1;
	my $funcname=$2;
	my $params=$3;
	print HEADER "#if defined(__NR_$funcname)\n";
	print HEADER "extern $rettype redirecting_sys_$funcname($params);\n";
	print HEADER "extern $rettype (*orig_sys_$funcname)($params);\n";
	print HEADER "#endif\n";
	print SOURCE "#if defined(__NR_$funcname)\n";
	print SOURCE "$rettype (*orig_sys_$funcname)($params);\n";
	print SOURCE "#endif\n";
	push(@funcnames,$funcname);
}
print SOURCE "
#define redir(a,b,c) b=sys_call_table[a];sys_call_table[a]=c
#define unredir(a,b,c) sys_call_table[a]=b

/* redirect syscalls (save old, install new) */
void init_redir_calltable(void)
{
";
foreach(@funcnames) {
	print SOURCE "#if defined( __NR_$_)\n";
	print SOURCE "\tredir(__NR_$_, orig_sys_$_, redirecting_sys_$_);\n";
	print SOURCE "#endif\n";
}
print SOURCE "}

/* unredirect syscalls
 this is problematic when several syscall-redirecting modules are loaded
 and not unloaded in reverse order!!!
*/
void restore_redir_calltable(void)
{
";
foreach(@funcnames) {
	print SOURCE "#if defined(__NR_$_)\n";
	print SOURCE "\tunredir(__NR_$_, orig_sys_$_, redirecting_sys_$_);\n";
	print SOURCE "#endif\n";
}
print SOURCE "}\n\n";

foreach(@lines) {
	if(m"^\s*$") {next}
	my $headonly=0; while(s/^-//g) {$headonly++;}
	my $redirtype=0; while(s/^\+//g) {$redirtype++;}
	$redirtype=("","d","w")[$redirtype];
	unless(/$funcre/) {next}
	my $rettype=$1;
	my $funcname=$2;
	my $params=$3;
	my @params=split(/\s*,\s*/,$params);
	my @paramnames=();
	my @localparams=();
	my @localdefs=();
	my @inputcopy=();
	my @outputcopy=();
	my $varcount=0;
	foreach(@params) {
	  /(\w+)$/;
	  my $name=$1;push(@paramnames,$name);
	  if(/(.*)\*\s*\w+$/){
		my $n="local$varcount";
		local $_=$1;
		my $input=s/const//g;s/^\s*//;s/\s*$//;
		my $def="\t$_ $n";
		my $addr="";
		if(/char/) {$def.="[REDIR_BUFSIZE]";
			if($input) {my $c=($varcount==1)?" redirect0($n);":"";push(@inputcopy,"\tif(strncpy_from_user($n, $paramnames[$varcount], REDIR_BUFSIZE)<0) return -EFAULT;$c")}
			else {push(@outputcopy,"\t\tif(result>=0){if(copy_to_user($paramnames[$varcount], local$varcount, result)) return -EFAULT;}\n")}
		} else {
			if($input) {$addr="p"; $def.=", *p$n=NULL";push(@inputcopy,"\n\t\tif($paramnames[$varcount] && copy_from_user((p$n=&$n), $paramnames[$varcount], sizeof($n))) return -EFAULT;")}
			else {$addr="&"; push(@outputcopy,"\t\tif(copy_to_user($paramnames[$varcount], &$n, sizeof($n))) return -EFAULT;\n")}
		}
		push(@localdefs,$def.";");
		push(@localparams,"$addr$n");
	  } else {push(@localparams,$name)}
	  $varcount++;
	}
	my $paramnames=join(", ", @paramnames);
	my $localdefs=join("\n",@localdefs); #"char local0[REDIR_BUFSIZE+1];";
	my $localparams=join(", ", @localparams);
	my $inputcopy=join("\n\t",@inputcopy[1..$#inputcopy]);
	my $outputcopy=join("",@outputcopy);
	if($headonly>1) {next}
	print SOURCE "#if defined(__NR_$funcname)
$rettype redirecting_sys_$funcname($params)\n{\n";
	unless($headonly) {
		print SOURCE "$localdefs
$inputcopy[0]
	if(${redirtype}redirect0(local0)) {
		$rettype result;$inputcopy
		BEGIN_KMEM
			result = orig_sys_$funcname($localparams);
		END_KMEM
$outputcopy		if(no_fallback(result)) return result;
	}
	return orig_sys_$funcname($paramnames);
";}
	print SOURCE "}\n#endif\n\n";
}

print SOURCE "\n/* EOF */\n";
close(SOURCE);
close(HEADER);

