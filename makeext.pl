#!/usr/bin/perl -w

use strict;

my $out=pop(@ARGV) or die "need output file";
open(HEADER,">$out.h");
open(SOURCE,">$out.c");

print SOURCE "/*redirecting extension file
was automatically generated by script $0 */

#include \"base.h\"
\n";
my @funcnames=();
my @lines=<>;
foreach(@lines) {
	s"#.*"";
	s"//.*"";
	if(m"^\s*$") {next}
	unless(/(\w+\s*\*?)\s+(\w+)\s*\((.*)\)\s*;/) {next}
	my $rettype=$1;
	my $funcname=$2;
	my $params=$3;
	print HEADER "extern $rettype redirecting_sys_$funcname($params);\n";
	print HEADER "extern $rettype (*orig_sys_$funcname)($params);\n";
	print SOURCE "$rettype (*orig_sys_$funcname)($params);\n";
	push(@funcnames,$funcname);
}
print SOURCE "
#define redir(a,b,c) b=sys_call_table[a];sys_call_table[a]=c
#define unredir(a,b,c) sys_call_table[a]=b

/* redirect syscalls (save old, install new) */
int init_module(void)
{
	int error;
	//char tobuf[ps]=defaultto, frombuf[ps]=defaultfrom;
	if(from) strncpy(frombuf,from,ps);
	if(to) strncpy(tobuf,to,ps);
	error=init_vars(frombuf,tobuf);
	if(error) return error;
	init_vars_once();
";
foreach(@funcnames) {
	print SOURCE "\tredir(SYS_$_, orig_sys_$_, redirecting_sys_$_);\n";
}
print SOURCE "	return 0;
}

/* unredirect syscalls
 this is problematic when several syscall-redirecting modules are loaded
 and not unloaded in reverse order!!!
*/
void cleanup_module(void)
{
	release_vars_once();
	release_vars();
";
foreach(@funcnames) {
	print SOURCE "\tunredir(SYS_$_, orig_sys_$_, redirecting_sys_$_);\n";
}
print SOURCE "}\n\n";

foreach(@lines) {
	if(m"^\s*$") {next}
	my $headonly=0; while(s/^-//g) {$headonly++;}
	my $redirtype=0; while(s/^\+//g) {$redirtype++;}
	$redirtype=("","d","w")[$redirtype];
	unless(/(\w+)\s+(\w+)\s*\((.*)\)\s*;/) {next}
	my $rettype=$1;
	my $funcname=$2;
	my $params=$3;
	my @params=split(/\s*,\s*/,$params);
	my @paramnames=();
	my @localparams=();
	my @localdefs=();
	my @inputcopy=();
	my @outputcopy=();
	my $varcount=0;
	foreach(@params) {
	  /(\w+)$/;
	  my $name=$1;push(@paramnames,$name);
	  if(/(.*)\*\s*\w+$/){
		my $n="local$varcount";
		local $_=$1;
		my $input=s/const//g;s/^\s*//;s/\s*$//;
		my $def="\t$_ $n";
		if(/char/) {$def.="[ps]";
			if($input) {my $c=($varcount==1)?" redirect(local$varcount);":"";push(@inputcopy,"\tif(strncpy_from_user(local$varcount, $paramnames[$varcount], ps)<0) return -EFAULT;$c")}
			else {push(@outputcopy,"\t\tif(result>=0){copy_to_user($paramnames[$varcount], local$varcount, result+1);}\n")}
		} else {
			if($input) {push(@inputcopy,"\tif(copy_from_user(&local$varcount, $paramnames[$varcount], sizeof(local$varcount))){return -EFAULT;}")}
			else {push(@outputcopy,"\t\tif(copy_to_user($paramnames[$varcount], &local$varcount, sizeof(local$varcount))){return -EFAULT;}\n")}
		}
		push(@localdefs,$def.";");
		my $addr=(/char/)?"":"&";
		push(@localparams,"$addr$n");
	  } else {push(@localparams,$name)}
	  $varcount++;
	}
	my $paramnames=join(", ", @paramnames);
	my $localdefs=join("\n",@localdefs); #"char local0[ps+1];";
	#my $localcopy=join(";\n\t\t",@localcopys);
	my $localparams=join(", ", @localparams);
	my $inputcopy=join("\n\t",@inputcopy[1..$#inputcopy]);
	my $outputcopy=join("",@outputcopy);
#	strncpy_from_user(local0, $paramnames[0], ps);
	if($headonly>1) {next}
	if($headonly) {
		print SOURCE "
$rettype redirecting_sys_$funcname($params)\n{\n}\n";
	} else {
		print SOURCE "
$rettype redirecting_sys_$funcname($params)
{
$localdefs
$inputcopy[0]
	if(${redirtype}redirect(local0)) {
		$rettype result;$inputcopy
		BEGIN_KMEM
			result = orig_sys_$funcname($localparams);
		END_KMEM
$outputcopy		if(result!=-ENOENT) return result;
	}
	return orig_sys_$funcname($paramnames);
}
";}
}

print SOURCE "\n/* EOF */\n"
